<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue 面试考点 | 前端之路</title>
    <meta name="description" content="Personal Website">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.192449cd.css" as="style"><link rel="preload" href="/assets/js/app.e6490847.js" as="script"><link rel="preload" href="/assets/js/19.3f677a26.js" as="script"><link rel="prefetch" href="/assets/js/10.2cbf406f.js"><link rel="prefetch" href="/assets/js/11.6230bdfc.js"><link rel="prefetch" href="/assets/js/12.fed9d7f7.js"><link rel="prefetch" href="/assets/js/13.bd71346f.js"><link rel="prefetch" href="/assets/js/14.91663730.js"><link rel="prefetch" href="/assets/js/15.afe89540.js"><link rel="prefetch" href="/assets/js/16.4e7f59eb.js"><link rel="prefetch" href="/assets/js/17.77286307.js"><link rel="prefetch" href="/assets/js/18.9da64000.js"><link rel="prefetch" href="/assets/js/2.9c48c232.js"><link rel="prefetch" href="/assets/js/20.7523e153.js"><link rel="prefetch" href="/assets/js/21.ad3c0855.js"><link rel="prefetch" href="/assets/js/22.bb901383.js"><link rel="prefetch" href="/assets/js/23.d9912c9e.js"><link rel="prefetch" href="/assets/js/24.53955016.js"><link rel="prefetch" href="/assets/js/25.86b73844.js"><link rel="prefetch" href="/assets/js/26.4aa4a47e.js"><link rel="prefetch" href="/assets/js/27.d66e7084.js"><link rel="prefetch" href="/assets/js/3.9df853b0.js"><link rel="prefetch" href="/assets/js/4.b1c1f607.js"><link rel="prefetch" href="/assets/js/5.8c110ab9.js"><link rel="prefetch" href="/assets/js/6.75e72418.js"><link rel="prefetch" href="/assets/js/7.e175f834.js"><link rel="prefetch" href="/assets/js/8.c039417d.js"><link rel="prefetch" href="/assets/js/9.5618bdf4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.192449cd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端之路</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/basic/css/css.html" class="nav-link">前端基础</a></div><div class="nav-item"><a href="/algorithm/components/array.html" class="nav-link">算法</a></div><div class="nav-item"><a href="/typeScript/" class="nav-link">TypeScript</a></div><div class="nav-item"><a href="/webpack/webpack_basic.html" class="nav-link">Webpack</a></div><div class="nav-item"><a href="/interview/vue/vue.html" class="nav-link">高频面试题</a></div><div class="nav-item"><a href="http://dairuining.top/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  music
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/basic/css/css.html" class="nav-link">前端基础</a></div><div class="nav-item"><a href="/algorithm/components/array.html" class="nav-link">算法</a></div><div class="nav-item"><a href="/typeScript/" class="nav-link">TypeScript</a></div><div class="nav-item"><a href="/webpack/webpack_basic.html" class="nav-link">Webpack</a></div><div class="nav-item"><a href="/interview/vue/vue.html" class="nav-link">高频面试题</a></div><div class="nav-item"><a href="http://dairuining.top/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  music
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>开始</span> <!----></p> <ul class="sidebar-group-items"></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>Vue 高频面试题</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/interview/vue/vue.html" class="sidebar-link">vue 常见用法</a></li><li><a href="/interview/vue/vueInterview.html" aria-current="page" class="active sidebar-link">vue 常见面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_1-mvvm-相关问题" class="sidebar-link">1. MVVM 相关问题</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_2-vue-中的响应式原理有什么缺陷？" class="sidebar-link">2. Vue 中的响应式原理有什么缺陷？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_3-对比其他框架" class="sidebar-link">3. 对比其他框架</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_4-异步更新队列" class="sidebar-link">4. 异步更新队列</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_5-vue-生命周期" class="sidebar-link">5. Vue 生命周期</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_6-v-show与v-if区别？" class="sidebar-link">6. v-show与v-if区别？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_7-说说你对-spa-单页面的理解" class="sidebar-link">7. 说说你对 SPA 单页面的理解</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_8-computed-和-watch-的区别？" class="sidebar-link">8. computed 和 watch 的区别？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_9-vue-组件-data-为什么必须是函数" class="sidebar-link">9. Vue 组件 data 为什么必须是函数?</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_10-谈谈你对-keep-alive-的了解？" class="sidebar-link">10. 谈谈你对 keep-alive 的了解？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_11-vue-中的-key-有什么作用？" class="sidebar-link">11. Vue 中的 key 有什么作用？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_12-ref的作用？" class="sidebar-link">12. ref的作用？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_13-vue-组件通信方式" class="sidebar-link">13. Vue 组件通信方式</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_14-请介绍一下你对-vuex-的理解？" class="sidebar-link">14. 请介绍一下你对 Vuex 的理解？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_15-请介绍一下你对vue-router的理解？" class="sidebar-link">15. 请介绍一下你对vue-router的理解？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_16-nexttick是什么？" class="sidebar-link">16. $nextTick是什么？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_17-vue的双向数据绑定原理是什么？" class="sidebar-link">17. Vue的双向数据绑定原理是什么？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_18-怎样理解-vue-的单向数据流？" class="sidebar-link">18. 怎样理解 Vue 的单向数据流？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_19-v-model-的原理？" class="sidebar-link">19. v-model 的原理？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_20-vue-怎么实现对象和数组的监听？" class="sidebar-link">20. Vue 怎么实现对象和数组的监听？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_21-proxy-与-object-defineproperty-对比" class="sidebar-link">21. Proxy 与 Object.defineProperty 对比</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_21-vm-set-解决对象不能响应的问题" class="sidebar-link">21. vm.$set() 解决对象不能响应的问题?</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_22-虚拟-dom-实现原理？" class="sidebar-link">22. 虚拟 DOM 实现原理？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_23-虚拟-dom-的优缺点？" class="sidebar-link">23. 虚拟 DOM 的优缺点？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_24-你有对-vue-项目进行哪些优化？" class="sidebar-link">24. 你有对 Vue 项目进行哪些优化？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_25-vue3-0-特性你有什么了解的吗？" class="sidebar-link">25. vue3.0 特性你有什么了解的吗？</a></li><li class="sidebar-sub-header"><a href="/interview/vue/vueInterview.html#_26-vue事件绑定原理说一下" class="sidebar-link">26. Vue事件绑定原理说一下</a></li></ul></li></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading"><span>浏览器与网络高频面试题</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/interview/network/browser.html" class="sidebar-link">浏览器高频面试题</a></li><li><a href="/interview/network/network.html" class="sidebar-link">网络高频面试题</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="_1-mvvm-相关问题"><a href="#_1-mvvm-相关问题" class="header-anchor">#</a> 1. MVVM 相关问题</h2> <h3 id="mvvm讲一下？"><a href="#mvvm讲一下？" class="header-anchor">#</a> MVVM讲一下？</h3> <ul><li>M - Model，Model 代表数据模型，用来定义数据修改和操作的业务逻辑</li> <li>V - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来</li> <li>VM - ViewModel，ViewModel 监听数据模型的改变和控制视图行为、处理用户交互，</li> <li>简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View</li></ul> <h3 id="mvvm响应式数据更新？"><a href="#mvvm响应式数据更新？" class="header-anchor">#</a> MVVM响应式数据更新？</h3> <ul><li>1.View 接收用户交互请求</li> <li>2.View 将请求转交给 ViewModel</li> <li>3.ViewModel 操作 Model 数据更新</li> <li>4.Model 更新完数据，通知 ViewModel 数据发生变化</li> <li>5.ViewModel 更新 View 数据</li></ul> <h3 id="mvc-数据更新流程"><a href="#mvc-数据更新流程" class="header-anchor">#</a> MVC 数据更新流程</h3> <ul><li>1.View 接收用户交互请求</li> <li>2.View 将请求转交给 Controller</li> <li>3.Controller 操作 Model 进行数据更新保存</li> <li>4.数据更新保存之后，Model 会通知 View 更新</li> <li>5.View 更新变化数据使用户得到反馈</li></ul> <h3 id="mvvm模式和mvc的不同点？"><a href="#mvvm模式和mvc的不同点？" class="header-anchor">#</a> MVVM模式和MVC的不同点？</h3> <ul><li>1.ViewModel 替换了 Controller，在UI层之下</li> <li>2.ViewModel 向 View 暴露它所需要的数据和指令对象</li> <li>3.ViewModel 接收来自 Model 的数据</li></ul> <p>概括起来，MVVM 是由 MVC 发展而来，通过在 Model 之上而在 View 之下增加一个非视觉的组件将来自Model的数据映射到View中。</p> <h2 id="_2-vue-中的响应式原理有什么缺陷？"><a href="#_2-vue-中的响应式原理有什么缺陷？" class="header-anchor">#</a> 2. Vue 中的响应式原理有什么缺陷？</h2> <h3 id="由于-javascript-的限制，vue-不能检测数组和对象的变化。"><a href="#由于-javascript-的限制，vue-不能检测数组和对象的变化。" class="header-anchor">#</a> 由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。</h3> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>对于对象：Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property
执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。<br> <strong>避免方法：</strong></p> <ul><li><ol><li>Vue.set(object, propertyName, value) 或 vm.$set(object, propertyName, value)</li></ol></li> <li><ol start="2"><li>this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })</li></ol></li></ul></div> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>对于数组: Vue 不能检测以下数组的变动：</p> <ul><li><ol><li>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</li></ol></li> <li><ol start="2"><li>当你修改数组的长度时，例如：vm.items.length = newLength</li></ol></li></ul> <p><strong>避免方法：</strong></p> <ul><li><ol><li>Vue.set(vm.items, indexOfItem, newValue) 或 vm.items.splice(indexOfItem, 1, newValue), vm.$set(vm.items, indexOfItem, newValue)</li></ol></li> <li><ol start="2"><li>vm.items.splice(newLength)</li></ol></li></ul></div> <h2 id="_3-对比其他框架"><a href="#_3-对比其他框架" class="header-anchor">#</a> 3. 对比其他框架</h2> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>React 和 Vue 有许多相似之处：</p> <ul><li><ol><li>使用 Virtual DOM</li></ol></li> <li><ol start="2"><li>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</li></ol></li> <li><ol start="3"><li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li></ol></li></ul> <p>React 比 Vue 更好的地方，比如更丰富的生态系统。</p></div> <h2 id="_4-异步更新队列"><a href="#_4-异步更新队列" class="header-anchor">#</a> 4. 异步更新队列</h2> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。
如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。
然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。
Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。</p></div> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>例如，当你设置 vm.someData = 'new value'，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。
多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。
虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。
为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用</p></div> <h2 id="_5-vue-生命周期"><a href="#_5-vue-生命周期" class="header-anchor">#</a> 5. Vue 生命周期</h2> <h3 id="什么是生命周期函数"><a href="#什么是生命周期函数" class="header-anchor">#</a> 什么是生命周期函数?</h3> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>生命周期函数，指的是 Vue 实例的创建、更新、销毁三个阶段所触发执行的函数。也就是从开始创建、初始化数据、编译模板、挂载DOM-&gt;渲染、更新-&gt;渲染、卸载等一系列过程，称为Vue的生命周期。</p></div> <h3 id="vue生命周期的作用是什么？"><a href="#vue生命周期的作用是什么？" class="header-anchor">#</a> Vue生命周期的作用是什么？</h3> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>它的生命周期有多个事件钩子，让我们在控制整个 Vue 实例的过程时更容易形成良好的逻辑。</p></div> <h3 id="vue生命周期总共有几个阶段？"><a href="#vue生命周期总共有几个阶段？" class="header-anchor">#</a> Vue生命周期总共有几个阶段？</h3> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>它可以总共分为8个阶段：创建前 / 后、载入前 / 后、更新前 / 后、销毁前 / 后</p></div> <h3 id="vue-生命周期触发的时机？"><a href="#vue-生命周期触发的时机？" class="header-anchor">#</a> Vue 生命周期触发的时机？</h3> <p><strong>1. 第一次页面加载会触发哪几个钩子？</strong></p> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>beforeCreate、created、beforeMount、mounted 这几个钩子</p></div> <p><strong>2. DOM 渲染在哪个周期中就已经完成？</strong></p> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>DOM 渲染在 mounted 就已经完成了</p></div> <p><strong>3. 每个生命周期适合哪些场景？</strong></p> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>beforecreate : 可以在这加个 loading 事件，在加载实例时触发<br>
created: 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用<br>
mounted : 挂载元素，获取到 DOM 节点<br>
updated : 如果对数据统一处理，在这里写上相应函数<br>
beforeDestroy : 可以做一个确认停止事件的确认框<br>
nextTick : 更新数据后立即操作 DOM</p></div> <p><strong>4. 生命周期钩子函数代表的意思？</strong></p> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined， 还没有初始化。<br>
created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法， 未挂载到DOM，el还没有<br>
beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的 dom节点<br>
mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点<br>
beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前， 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器<br>
updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环<br>
beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件<br>
destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁</p></div> <h2 id="_6-v-show与v-if区别？"><a href="#_6-v-show与v-if区别？" class="header-anchor">#</a> 6. v-show与v-if区别？</h2> <div class="tip custom-block"><p class="custom-block-title">提示</p> <ol><li>v-show 是 CSS 切换，v-if 是完整的销毁和创建</li> <li>使用频繁时用 v-show，运行时较少改变时使用 v-if</li> <li>v-if='false'  v-if是条件渲染，当false的时候不会渲染</li></ol></div> <h2 id="_7-说说你对-spa-单页面的理解"><a href="#_7-说说你对-spa-单页面的理解" class="header-anchor">#</a> 7. 说说你对 SPA 单页面的理解</h2> <div class="tip custom-block"><p class="custom-block-title">概念</p> <p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p></div> <div class="tip custom-block"><p class="custom-block-title">优点</p> <ol><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li> <li>基于上面一点，SPA 相对对服务器压力小；</li> <li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ol></div> <div class="tip custom-block"><p class="custom-block-title">缺点</p> <ol><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li> <li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li> <li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ol></div> <h2 id="_8-computed-和-watch-的区别？"><a href="#_8-computed-和-watch-的区别？" class="header-anchor">#</a> 8. computed 和 watch 的区别？</h2> <div class="tip custom-block"><p class="custom-block-title">区别</p> <p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，才会重新计算 computed 的值；<br>
watch： 更多的是「观察」的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作；</p></div> <div class="tip custom-block"><p class="custom-block-title">运用场景</p> <ol><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算。</li> <li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，这些都是计算属性无法做到的。</li></ol></div> <h2 id="_9-vue-组件-data-为什么必须是函数"><a href="#_9-vue-组件-data-为什么必须是函数" class="header-anchor">#</a> 9. Vue 组件 data 为什么必须是函数?</h2> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p>因为组件是可以复用的,JS 对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染, 产生副作用。 所以一个组件的 data 选项必须是一个函数。</p></div> <h2 id="_10-谈谈你对-keep-alive-的了解？"><a href="#_10-谈谈你对-keep-alive-的了解？" class="header-anchor">#</a> 10. 谈谈你对 keep-alive 的了解？</h2> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p><strong>keep-alive</strong> 是 <strong>Vue</strong> 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：<br>
1.一般结合路由和动态组件一起使用，用于缓存组件；<br>
2.提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；<br>
3.对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</p></div> <h2 id="_11-vue-中的-key-有什么作用？"><a href="#_11-vue-中的-key-有什么作用？" class="header-anchor">#</a> 11. Vue 中的 key 有什么作用？</h2> <div class="tip custom-block"><p class="custom-block-title">提示</p> <p><strong>作用：</strong> key 是为 Vue 中 vnode 的唯一标记，通过这个key，我们的 diff 操作可以更准确、更快速。<br> <strong>更准确：</strong> 因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。<br> <strong>更快速：</strong> 利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</p></div> <h2 id="_12-ref的作用？"><a href="#_12-ref的作用？" class="header-anchor">#</a> 12. ref的作用？</h2> <div class="tip custom-block"><p class="custom-block-title">作用</p> <ol><li>获取dom元素 =&gt; this.$refs.box</li> <li>获取子组件中的data =&gt; this.$refs.box.msg</li> <li>调用子组件中的方法 =&gt; this.$refs.box.open()</li></ol></div> <h2 id="_13-vue-组件通信方式"><a href="#_13-vue-组件通信方式" class="header-anchor">#</a> 13. Vue 组件通信方式</h2> <div class="tip custom-block"><p class="custom-block-title">提示</p> <ol><li>props / $emit</li> <li>.async / $emit('update:foo', newValue)</li> <li>EventBus</li> <li>vuex</li> <li>$attrs / $listeners</li> <li>provide / inject (底层的通用组件时，使用频率会很高)</li> <li>$parent / $children</li> <li>ref / $refs</li></ol></div> <h2 id="_14-请介绍一下你对-vuex-的理解？"><a href="#_14-请介绍一下你对-vuex-的理解？" class="header-anchor">#</a> 14. 请介绍一下你对 Vuex 的理解？</h2> <div class="tip custom-block"><p class="custom-block-title">概念</p> <p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。每一个 Vuex应用的核心就是 store（仓库）。&quot;store&quot; 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p></div> <div class="tip custom-block"><p class="custom-block-title">响应式</p> <p>（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。<br>
（2）改变 store 中的状态的唯一途径就是显式地提交 (commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p></div> <div class="tip custom-block"><p class="custom-block-title">模块</p> <p>主要包括以下几个模块：</p> <ol><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li> <li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li> <li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li> <li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li> <li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ol></div> <h2 id="_15-请介绍一下你对vue-router的理解？"><a href="#_15-请介绍一下你对vue-router的理解？" class="header-anchor">#</a> 15. 请介绍一下你对vue-router的理解？</h2> <div class="tip custom-block"><p class="custom-block-title">模式</p> <p>vue-router 有 3 种路由模式：hash、history、abstract</p> <ol><li>hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</li> <li>history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</li> <li>abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</li></ol></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">switch</span> <span class="token punctuation">(</span>mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token string">'history'</span><span class="token operator">:</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HTML5History</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
	<span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'hash'</span><span class="token operator">:</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>fallback<span class="token punctuation">)</span>
	<span class="token keyword">break</span>
  <span class="token keyword">case</span> <span class="token string">'abstract'</span><span class="token operator">:</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>history <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AbstractHistory</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">.</span>base<span class="token punctuation">)</span>
	<span class="token keyword">break</span>
  <span class="token keyword">default</span><span class="token operator">:</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">invalid mode: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>mode<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">hash</p> <p>1）hash 模式的实现原理 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 #后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'</p> <p><strong>hash 路由模式的实现主要是基于下面几个特性：</strong></p> <ol><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li> <li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的 回退、前进按钮控制 hash 的切换；</li> <li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li> <li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ol></div> <div class="tip custom-block"><p class="custom-block-title">history</p> <p>2）history 模式的实现原理 HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一 个历史记录，后者是直接替换当前的历史记录，如下所示：</p> <ol><li>window.history.pushState(null, null, path);</li> <li>window.history.replaceState(null, null, path);</li></ol> <p><strong>history 路由模式的实现主要基于存在下面几个特性：</strong></p> <ol><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化；</li> <li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li> <li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ol></div> <div class="tip custom-block"><p class="custom-block-title">导航钩子函数（导航守卫）</p> <p><strong>全局守卫</strong></p> <ol><li>router.beforeEach 全局前置守卫 进入路由之前</li> <li>router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用</li> <li>router.afterEach 全局后置钩子 进入路由之后</li></ol> <p><strong>路由独享的守卫</strong><br>
你可以在路由配置上直接定义 beforeEnter 守卫</p> <p><strong>组件内的守卫</strong><br>
你可以在路由组件内直接定义以下路由导航守卫</p></div> <h2 id="_16-nexttick是什么？"><a href="#_16-nexttick是什么？" class="header-anchor">#</a> 16. $nextTick是什么？</h2> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>vue 实现响应式并不是数据发生变化后 DOM 立即变化，而是按照一定的策略来进行 DOM 更新。<br>
nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 nextTick，则可以在回调中获取更新后的 DOM。</p></div> <h2 id="_17-vue的双向数据绑定原理是什么？"><a href="#_17-vue的双向数据绑定原理是什么？" class="header-anchor">#</a> 17. Vue的双向数据绑定原理是什么？</h2> <p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。<br>
主要分为以下几个步骤：</p> <div class="tip custom-block"><p class="custom-block-title">步骤1</p> <p>1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</p></div> <div class="tip custom-block"><p class="custom-block-title">步骤2</p> <p>2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p></div> <div class="tip custom-block"><p class="custom-block-title">步骤3</p> <p>3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:<br>
①在自身实例化时往属性订阅器(dep)里面添加自己。<br>
②自身必须有一个 update() 方法。<br>
③待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。</p></div> <div class="tip custom-block"><p class="custom-block-title">步骤4</p> <p>4、MVVM作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p></div> <h2 id="_18-怎样理解-vue-的单向数据流？"><a href="#_18-怎样理解-vue-的单向数据流？" class="header-anchor">#</a> 18. 怎样理解 Vue 的单向数据流？</h2> <div class="tip custom-block"><p class="custom-block-title">概念</p> <p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。<br>
额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。</p></div> <h2 id="_19-v-model-的原理？"><a href="#_19-v-model-的原理？" class="header-anchor">#</a> 19. v-model 的原理？</h2> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p> <ol><li>text 和 textarea 元素使用 value 属性和 input 事件；</li> <li>checkbox 和 radio 使用 checked 属性和 change 事件；</li> <li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ol></div> <p><strong>以 input 表单元素为例：</strong></p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">'</span>something<span class="token punctuation">'</span></span><span class="token punctuation">&gt;</span></span>

相当于
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something<span class="token punctuation">&quot;</span></span> <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>something = $event.target.value<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 父组件：</span>
<span class="token operator">&lt;</span>ModelChild v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;message&quot;</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>ModelChild<span class="token operator">&gt;</span>

<span class="token comment">// 子组件：</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">{</span>value<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
props<span class="token operator">:</span><span class="token punctuation">{</span>
    value<span class="token operator">:</span> String
<span class="token punctuation">}</span><span class="token punctuation">,</span>
methods<span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
     <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token string">'小红'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><h2 id="_20-vue-怎么实现对象和数组的监听？"><a href="#_20-vue-怎么实现对象和数组的监听？" class="header-anchor">#</a> 20. Vue 怎么实现对象和数组的监听？</h2> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是  Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：</p></div> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Observe a list of Array items.
 */</span>
<span class="token function">observeArray</span> <span class="token punctuation">(</span><span class="token parameter">items<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> items<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">observe</span><span class="token punctuation">(</span>items<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// observe 功能为监测数据的变化</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 对属性进行递归遍历
 */</span>
<span class="token keyword">let</span> childOb <span class="token operator">=</span> <span class="token operator">!</span>shallow <span class="token operator">&amp;&amp;</span> <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token comment">// observe 功能为监测数据的变化</span>
</code></pre></div><p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p> <h2 id="_21-proxy-与-object-defineproperty-对比"><a href="#_21-proxy-与-object-defineproperty-对比" class="header-anchor">#</a> 21. Proxy 与 Object.defineProperty 对比</h2> <div class="tip custom-block"><p class="custom-block-title">Proxy 的优势如下:</p> <ol><li>Proxy 可以直接监听对象而非属性；</li> <li>Proxy 可以直接监听数组的变化；</li> <li>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；</li> <li>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；</li> <li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；</li></ol></div> <div class="tip custom-block"><p class="custom-block-title">Object.defineProperty 的优势如下:</p> <p>兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。</p></div> <h2 id="_21-vm-set-解决对象不能响应的问题"><a href="#_21-vm-set-解决对象不能响应的问题" class="header-anchor">#</a> 21. vm.$set() 解决对象不能响应的问题?</h2> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)  来实现为对象添加响应式属性，那框架本身是如何实现的呢？</p></div> <p>我们查看对应的 Vue 源码：vue/src/core/instance/index.js</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">set</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> key<span class="token operator">:</span> any<span class="token punctuation">,</span> val<span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> any <span class="token punctuation">{</span>
  <span class="token comment">// target 为数组  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span>
    target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
    <span class="token comment">// 利用数组的splice变异方法触发响应式  </span>
    target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// key 已经存在，直接修改属性值  </span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__
  <span class="token comment">// target 本身就不是响应式数据, 直接赋值</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
    <span class="token keyword">return</span> val
  <span class="token punctuation">}</span>
  <span class="token comment">// 对属性进行响应式处理</span>
  <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
  ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> val
<span class="token punctuation">}</span>
</code></pre></div><div class="tip custom-block"><p class="custom-block-title">我们阅读以上源码可知，vm.$set 的实现原理是：</p> <ol><li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li> <li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li></ol></div> <h2 id="_22-虚拟-dom-实现原理？"><a href="#_22-虚拟-dom-实现原理？" class="header-anchor">#</a> 22. 虚拟 DOM 实现原理？</h2> <div class="tip custom-block"><p class="custom-block-title">虚拟 DOM 的实现原理主要包括以下 3 部分：</p> <ol><li>用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；</li> <li>diff 算法 — 比较两棵虚拟 DOM 树的差异；</li> <li>pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。</li></ol></div> <h2 id="_23-虚拟-dom-的优缺点？"><a href="#_23-虚拟-dom-的优缺点？" class="header-anchor">#</a> 23. 虚拟 DOM 的优缺点？</h2> <div class="tip custom-block"><p class="custom-block-title">优点：</p> <ol><li><strong>保证性能下限：</strong> 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；</li> <li><strong>无需手动操作 DOM：</strong> 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；</li> <li><strong>跨平台：</strong> 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。</li></ol></div> <div class="tip custom-block"><p class="custom-block-title">缺点:</p> <p><strong>无法进行极致优化：</strong> 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。</p></div> <h2 id="_24-你有对-vue-项目进行哪些优化？"><a href="#_24-你有对-vue-项目进行哪些优化？" class="header-anchor">#</a> 24. 你有对 Vue 项目进行哪些优化？</h2> <div class="tip custom-block"><p class="custom-block-title">（1）代码层面的优化</p> <ol><li>v-if 和 v-show 区分使用场景</li> <li>computed 和 watch  区分使用场景</li> <li>v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</li> <li>长列表性能优化</li> <li>事件的销毁</li> <li>图片资源懒加载</li> <li>路由懒加载</li> <li>第三方插件的按需引入</li> <li>优化无限列表性能</li> <li>服务端渲染 SSR or 预渲染</li></ol></div> <div class="tip custom-block"><p class="custom-block-title">（2）Webpack 层面的优化</p> <ol><li>Webpack 对图片进行压缩</li> <li>减少 ES6 转为 ES5 的冗余代码</li> <li>提取公共代码</li> <li>模板预编译</li> <li>提取组件的 CSS</li> <li>优化 SourceMap</li> <li>构建结果输出分析</li> <li>Vue 项目的编译优化</li></ol></div> <div class="tip custom-block"><p class="custom-block-title">（3）基础的 Web 技术的优化</p> <ol><li>开启 gzip 压缩</li> <li>浏览器缓存</li> <li>CDN 的使用</li> <li>使用 Chrome Performance 查找性能瓶颈</li></ol></div> <h2 id="_25-vue3-0-特性你有什么了解的吗？"><a href="#_25-vue3-0-特性你有什么了解的吗？" class="header-anchor">#</a> 25. vue3.0 特性你有什么了解的吗？</h2> <p>Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：</p> <div class="tip custom-block"><p class="custom-block-title">（1）监测机制的改变</p> <p>3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</p> <ol><li>只能监测属性，不能监测对象</li> <li>检测属性的添加和删除；</li> <li>检测数组索引和长度的变更；</li> <li>支持 Map、Set、WeakMap 和 WeakSet。</li></ol></div> <div class="tip custom-block"><p class="custom-block-title">新的 observer 还提供了以下特性：</p> <ol><li>用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。</li> <li>默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。</li> <li>更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。</li> <li>不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。</li> <li>更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。</li></ol></div> <div class="tip custom-block"><p class="custom-block-title">（2）模板</p> <p>模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。
同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</p></div> <h2 id="_26-vue事件绑定原理说一下"><a href="#_26-vue事件绑定原理说一下" class="header-anchor">#</a> 26. Vue事件绑定原理说一下</h2> <div class="tip custom-block"><p class="custom-block-title">TIP</p> <p>原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。</p></div></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/interview/vue/vue.html" class="prev">
          vue 常见用法
        </a></span> <span class="next"><a href="/interview/network/browser.html">
          浏览器高频面试题
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.e6490847.js" defer></script><script src="/assets/js/19.3f677a26.js" defer></script>
  </body>
</html>
