(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{201:function(t,s,a){},222:function(t,s,a){"use strict";a(201)},248:function(t,s,a){"use strict";a.r(s);a(222);var e=a(0),v=Object(e.a)({},(function(){var t=this.$createElement;this._self._c;return this._m(0)}),[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[a("h2",{attrs:{id:"_1-mvvm-相关问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-mvvm-相关问题"}},[t._v("#")]),t._v(" 1. MVVM 相关问题")]),t._v(" "),a("h3",{attrs:{id:"mvvm讲一下？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm讲一下？"}},[t._v("#")]),t._v(" MVVM讲一下？")]),t._v(" "),a("ul",[a("li",[t._v("M - Model，Model 代表数据模型，用来定义数据修改和操作的业务逻辑")]),t._v(" "),a("li",[t._v("V - View，View 代表 UI 组件，它负责将数据模型转化为 UI 展现出来")]),t._v(" "),a("li",[t._v("VM - ViewModel，ViewModel 监听数据模型的改变和控制视图行为、处理用户交互，")]),t._v(" "),a("li",[t._v("简单理解就是一个同步 View 和 Model 的对象，连接 Model 和 View")])]),t._v(" "),a("h3",{attrs:{id:"mvvm响应式数据更新？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm响应式数据更新？"}},[t._v("#")]),t._v(" MVVM响应式数据更新？")]),t._v(" "),a("ul",[a("li",[t._v("1.View 接收用户交互请求")]),t._v(" "),a("li",[t._v("2.View 将请求转交给 ViewModel")]),t._v(" "),a("li",[t._v("3.ViewModel 操作 Model 数据更新")]),t._v(" "),a("li",[t._v("4.Model 更新完数据，通知 ViewModel 数据发生变化")]),t._v(" "),a("li",[t._v("5.ViewModel 更新 View 数据")])]),t._v(" "),a("h3",{attrs:{id:"mvc-数据更新流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvc-数据更新流程"}},[t._v("#")]),t._v(" MVC 数据更新流程")]),t._v(" "),a("ul",[a("li",[t._v("1.View 接收用户交互请求")]),t._v(" "),a("li",[t._v("2.View 将请求转交给 Controller")]),t._v(" "),a("li",[t._v("3.Controller 操作 Model 进行数据更新保存")]),t._v(" "),a("li",[t._v("4.数据更新保存之后，Model 会通知 View 更新")]),t._v(" "),a("li",[t._v("5.View 更新变化数据使用户得到反馈")])]),t._v(" "),a("h3",{attrs:{id:"mvvm模式和mvc的不同点？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mvvm模式和mvc的不同点？"}},[t._v("#")]),t._v(" MVVM模式和MVC的不同点？")]),t._v(" "),a("ul",[a("li",[t._v("1.ViewModel 替换了 Controller，在UI层之下")]),t._v(" "),a("li",[t._v("2.ViewModel 向 View 暴露它所需要的数据和指令对象")]),t._v(" "),a("li",[t._v("3.ViewModel 接收来自 Model 的数据")])]),t._v(" "),a("p",[t._v("概括起来，MVVM 是由 MVC 发展而来，通过在 Model 之上而在 View 之下增加一个非视觉的组件将来自Model的数据映射到View中。")]),t._v(" "),a("h2",{attrs:{id:"_2-vue-中的响应式原理有什么缺陷？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-vue-中的响应式原理有什么缺陷？"}},[t._v("#")]),t._v(" 2. Vue 中的响应式原理有什么缺陷？")]),t._v(" "),a("h3",{attrs:{id:"由于-javascript-的限制，vue-不能检测数组和对象的变化。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#由于-javascript-的限制，vue-不能检测数组和对象的变化。"}},[t._v("#")]),t._v(" 由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("对于对象：Vue 无法检测 property 的添加或移除。由于 Vue 会在初始化实例时对 property\n执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。"),a("br"),t._v(" "),a("strong",[t._v("避免方法：")])]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("Vue.set(object, propertyName, value) 或 vm.$set(object, propertyName, value)")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })")])])])])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("对于数组: Vue 不能检测以下数组的变动：")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("当你修改数组的长度时，例如：vm.items.length = newLength")])])])]),t._v(" "),a("p",[a("strong",[t._v("避免方法：")])]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("Vue.set(vm.items, indexOfItem, newValue) 或 vm.items.splice(indexOfItem, 1, newValue), vm.$set(vm.items, indexOfItem, newValue)")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("vm.items.splice(newLength)")])])])])]),t._v(" "),a("h2",{attrs:{id:"_3-对比其他框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-对比其他框架"}},[t._v("#")]),t._v(" 3. 对比其他框架")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("React 和 Vue 有许多相似之处：")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("使用 Virtual DOM")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。")])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"3"}},[a("li",[t._v("将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。")])])])]),t._v(" "),a("p",[t._v("React 比 Vue 更好的地方，比如更丰富的生态系统。")])]),t._v(" "),a("h2",{attrs:{id:"_4-异步更新队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-异步更新队列"}},[t._v("#")]),t._v(" 4. 异步更新队列")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。\n如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。\n然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。\nVue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("例如，当你设置 vm.someData = 'new value'，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。\n多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。\n虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。\n为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用")])]),t._v(" "),a("h2",{attrs:{id:"_5-vue-生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-vue-生命周期"}},[t._v("#")]),t._v(" 5. Vue 生命周期")]),t._v(" "),a("h3",{attrs:{id:"什么是生命周期函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是生命周期函数"}},[t._v("#")]),t._v(" 什么是生命周期函数?")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("生命周期函数，指的是 Vue 实例的创建、更新、销毁三个阶段所触发执行的函数。也就是从开始创建、初始化数据、编译模板、挂载DOM->渲染、更新->渲染、卸载等一系列过程，称为Vue的生命周期。")])]),t._v(" "),a("h3",{attrs:{id:"vue生命周期的作用是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期的作用是什么？"}},[t._v("#")]),t._v(" Vue生命周期的作用是什么？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("它的生命周期有多个事件钩子，让我们在控制整个 Vue 实例的过程时更容易形成良好的逻辑。")])]),t._v(" "),a("h3",{attrs:{id:"vue生命周期总共有几个阶段？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期总共有几个阶段？"}},[t._v("#")]),t._v(" Vue生命周期总共有几个阶段？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("它可以总共分为8个阶段：创建前 / 后、载入前 / 后、更新前 / 后、销毁前 / 后")])]),t._v(" "),a("h3",{attrs:{id:"vue-生命周期触发的时机？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期触发的时机？"}},[t._v("#")]),t._v(" Vue 生命周期触发的时机？")]),t._v(" "),a("p",[a("strong",[t._v("1. 第一次页面加载会触发哪几个钩子？")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("beforeCreate、created、beforeMount、mounted 这几个钩子")])]),t._v(" "),a("p",[a("strong",[t._v("2. DOM 渲染在哪个周期中就已经完成？")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("DOM 渲染在 mounted 就已经完成了")])]),t._v(" "),a("p",[a("strong",[t._v("3. 每个生命周期适合哪些场景？")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("beforecreate : 可以在这加个 loading 事件，在加载实例时触发"),a("br"),t._v("\ncreated: 初始化完成时的事件写在这里，如在这结束 loading 事件，异步请求也适宜在这里调用"),a("br"),t._v("\nmounted : 挂载元素，获取到 DOM 节点"),a("br"),t._v("\nupdated : 如果对数据统一处理，在这里写上相应函数"),a("br"),t._v("\nbeforeDestroy : 可以做一个确认停止事件的确认框"),a("br"),t._v("\nnextTick : 更新数据后立即操作 DOM")])]),t._v(" "),a("p",[a("strong",[t._v("4. 生命周期钩子函数代表的意思？")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined， 还没有初始化。"),a("br"),t._v("\ncreated阶段：vue实例的数据对象data有了，可以访问里面的数据和方法， 未挂载到DOM，el还没有"),a("br"),t._v("\nbeforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的 dom节点"),a("br"),t._v("\nmounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点"),a("br"),t._v("\nbeforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前， 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器"),a("br"),t._v("\nupdated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环"),a("br"),t._v("\nbeforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件"),a("br"),t._v("\ndestroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁")])]),t._v(" "),a("h2",{attrs:{id:"_6-v-show与v-if区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-v-show与v-if区别？"}},[t._v("#")]),t._v(" 6. v-show与v-if区别？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("ol",[a("li",[t._v("v-show 是 CSS 切换，v-if 是完整的销毁和创建")]),t._v(" "),a("li",[t._v("使用频繁时用 v-show，运行时较少改变时使用 v-if")]),t._v(" "),a("li",[t._v("v-if='false'  v-if是条件渲染，当false的时候不会渲染")])])]),t._v(" "),a("h2",{attrs:{id:"_7-说说你对-spa-单页面的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-说说你对-spa-单页面的理解"}},[t._v("#")]),t._v(" 7. 说说你对 SPA 单页面的理解")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("概念")]),t._v(" "),a("p",[t._v("SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("优点")]),t._v(" "),a("ol",[a("li",[t._v("用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；")]),t._v(" "),a("li",[t._v("基于上面一点，SPA 相对对服务器压力小；")]),t._v(" "),a("li",[t._v("前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；")])])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("缺点")]),t._v(" "),a("ol",[a("li",[t._v("初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；")]),t._v(" "),a("li",[t._v("前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；")]),t._v(" "),a("li",[t._v("SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。")])])]),t._v(" "),a("h2",{attrs:{id:"_8-computed-和-watch-的区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-computed-和-watch-的区别？"}},[t._v("#")]),t._v(" 8. computed 和 watch 的区别？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("区别")]),t._v(" "),a("p",[t._v("computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，才会重新计算 computed 的值；"),a("br"),t._v("\nwatch： 更多的是「观察」的作用，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作；")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("运用场景")]),t._v(" "),a("ol",[a("li",[t._v("当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算。")]),t._v(" "),a("li",[t._v("当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，这些都是计算属性无法做到的。")])])]),t._v(" "),a("h2",{attrs:{id:"_9-vue-组件-data-为什么必须是函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue-组件-data-为什么必须是函数"}},[t._v("#")]),t._v(" 9. Vue 组件 data 为什么必须是函数?")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("因为组件是可以复用的,JS 对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染, 产生副作用。 所以一个组件的 data 选项必须是一个函数。")])]),t._v(" "),a("h2",{attrs:{id:"_10-谈谈你对-keep-alive-的了解？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-谈谈你对-keep-alive-的了解？"}},[t._v("#")]),t._v(" 10. 谈谈你对 keep-alive 的了解？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[a("strong",[t._v("keep-alive")]),t._v(" 是 "),a("strong",[t._v("Vue")]),t._v(" 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性："),a("br"),t._v("\n1.一般结合路由和动态组件一起使用，用于缓存组件；"),a("br"),t._v("\n2.提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；"),a("br"),t._v("\n3.对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。")])]),t._v(" "),a("h2",{attrs:{id:"_11-vue-中的-key-有什么作用？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue-中的-key-有什么作用？"}},[t._v("#")]),t._v(" 11. Vue 中的 key 有什么作用？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[a("strong",[t._v("作用：")]),t._v(" key 是为 Vue 中 vnode 的唯一标记，通过这个key，我们的 diff 操作可以更准确、更快速。"),a("br"),t._v(" "),a("strong",[t._v("更准确：")]),t._v(" 因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。"),a("br"),t._v(" "),a("strong",[t._v("更快速：")]),t._v(" 利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快")])]),t._v(" "),a("h2",{attrs:{id:"_12-ref的作用？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-ref的作用？"}},[t._v("#")]),t._v(" 12. ref的作用？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("作用")]),t._v(" "),a("ol",[a("li",[t._v("获取dom元素 => this.$refs.box")]),t._v(" "),a("li",[t._v("获取子组件中的data => this.$refs.box.msg")]),t._v(" "),a("li",[t._v("调用子组件中的方法 => this.$refs.box.open()")])])]),t._v(" "),a("h2",{attrs:{id:"_13-vue-组件通信方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue-组件通信方式"}},[t._v("#")]),t._v(" 13. Vue 组件通信方式")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("ol",[a("li",[t._v("props / $emit")]),t._v(" "),a("li",[t._v(".async / $emit('update:foo', newValue)")]),t._v(" "),a("li",[t._v("EventBus")]),t._v(" "),a("li",[t._v("vuex")]),t._v(" "),a("li",[t._v("$attrs / $listeners")]),t._v(" "),a("li",[t._v("provide / inject (底层的通用组件时，使用频率会很高)")]),t._v(" "),a("li",[t._v("$parent / $children")]),t._v(" "),a("li",[t._v("ref / $refs")])])]),t._v(" "),a("h2",{attrs:{id:"_14-请介绍一下你对-vuex-的理解？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-请介绍一下你对-vuex-的理解？"}},[t._v("#")]),t._v(" 14. 请介绍一下你对 Vuex 的理解？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("概念")]),t._v(" "),a("p",[t._v('Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。每一个 Vuex应用的核心就是 store（仓库）。"store" 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。')])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("响应式")]),t._v(" "),a("p",[t._v("（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。"),a("br"),t._v("\n（2）改变 store 中的状态的唯一途径就是显式地提交 (commit)mutation。这样使得我们可以方便地跟踪每一个状态的变化。")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("模块")]),t._v(" "),a("p",[t._v("主要包括以下几个模块：")]),t._v(" "),a("ol",[a("li",[t._v("State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。")]),t._v(" "),a("li",[t._v("Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。")]),t._v(" "),a("li",[t._v("Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。")]),t._v(" "),a("li",[t._v("Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。")]),t._v(" "),a("li",[t._v("Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。")])])]),t._v(" "),a("h2",{attrs:{id:"_15-请介绍一下你对vue-router的理解？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-请介绍一下你对vue-router的理解？"}},[t._v("#")]),t._v(" 15. 请介绍一下你对vue-router的理解？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("模式")]),t._v(" "),a("p",[t._v("vue-router 有 3 种路由模式：hash、history、abstract")]),t._v(" "),a("ol",[a("li",[t._v("hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；")]),t._v(" "),a("li",[t._v("history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；")]),t._v(" "),a("li",[t._v("abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.")])])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("switch")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mode"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'history'")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("history "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HTML5History")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("base"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hash'")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("history "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashHistory")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("base"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("fallback"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'abstract'")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("history "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AbstractHistory")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" options"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("base"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("process"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("env"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NODE_ENV")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'production'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("assert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token template-string"}},[a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("invalid mode: ")]),a("span",{pre:!0,attrs:{class:"token interpolation"}},[a("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("${")]),t._v("mode"),a("span",{pre:!0,attrs:{class:"token interpolation-punctuation punctuation"}},[t._v("}")])]),a("span",{pre:!0,attrs:{class:"token template-punctuation string"}},[t._v("`")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("hash")]),t._v(" "),a("p",[t._v("1）hash 模式的实现原理 早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 #后面的内容。比如下面这个网站，它的 location.hash 的值为 '#search'")]),t._v(" "),a("p",[a("strong",[t._v("hash 路由模式的实现主要是基于下面几个特性：")])]),t._v(" "),a("ol",[a("li",[t._v("URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；")]),t._v(" "),a("li",[t._v("hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的 回退、前进按钮控制 hash 的切换；")]),t._v(" "),a("li",[t._v("可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用 JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；")]),t._v(" "),a("li",[t._v("我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。")])])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("history")]),t._v(" "),a("p",[t._v("2）history 模式的实现原理 HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一 个历史记录，后者是直接替换当前的历史记录，如下所示：")]),t._v(" "),a("ol",[a("li",[t._v("window.history.pushState(null, null, path);")]),t._v(" "),a("li",[t._v("window.history.replaceState(null, null, path);")])]),t._v(" "),a("p",[a("strong",[t._v("history 路由模式的实现主要基于存在下面几个特性：")])]),t._v(" "),a("ol",[a("li",[t._v("pushState 和 repalceState 两个 API 来操作实现 URL 的变化；")]),t._v(" "),a("li",[t._v("我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；")]),t._v(" "),a("li",[t._v("history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。")])])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("导航钩子函数（导航守卫）")]),t._v(" "),a("p",[a("strong",[t._v("全局守卫")])]),t._v(" "),a("ol",[a("li",[t._v("router.beforeEach 全局前置守卫 进入路由之前")]),t._v(" "),a("li",[t._v("router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用")]),t._v(" "),a("li",[t._v("router.afterEach 全局后置钩子 进入路由之后")])]),t._v(" "),a("p",[a("strong",[t._v("路由独享的守卫")]),a("br"),t._v("\n你可以在路由配置上直接定义 beforeEnter 守卫")]),t._v(" "),a("p",[a("strong",[t._v("组件内的守卫")]),a("br"),t._v("\n你可以在路由组件内直接定义以下路由导航守卫")])]),t._v(" "),a("h2",{attrs:{id:"_16-nexttick是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-nexttick是什么？"}},[t._v("#")]),t._v(" 16. $nextTick是什么？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("vue 实现响应式并不是数据发生变化后 DOM 立即变化，而是按照一定的策略来进行 DOM 更新。"),a("br"),t._v("\nnextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 nextTick，则可以在回调中获取更新后的 DOM。")])]),t._v(" "),a("h2",{attrs:{id:"_17-vue的双向数据绑定原理是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-vue的双向数据绑定原理是什么？"}},[t._v("#")]),t._v(" 17. Vue的双向数据绑定原理是什么？")]),t._v(" "),a("p",[t._v("vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。"),a("br"),t._v("\n主要分为以下几个步骤：")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("步骤1")]),t._v(" "),a("p",[t._v("1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("步骤2")]),t._v(" "),a("p",[t._v("2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("步骤3")]),t._v(" "),a("p",[t._v("3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:"),a("br"),t._v("\n①在自身实例化时往属性订阅器(dep)里面添加自己。"),a("br"),t._v("\n②自身必须有一个 update() 方法。"),a("br"),t._v("\n③待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。")])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("步骤4")]),t._v(" "),a("p",[t._v("4、MVVM作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。")])]),t._v(" "),a("h2",{attrs:{id:"_18-怎样理解-vue-的单向数据流？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-怎样理解-vue-的单向数据流？"}},[t._v("#")]),t._v(" 18. 怎样理解 Vue 的单向数据流？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("概念")]),t._v(" "),a("p",[t._v("所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。"),a("br"),t._v("\n额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。")])]),t._v(" "),a("h2",{attrs:{id:"_19-v-model-的原理？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-v-model-的原理？"}},[t._v("#")]),t._v(" 19. v-model 的原理？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("我们在 vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定，我们知道 v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件：")]),t._v(" "),a("ol",[a("li",[t._v("text 和 textarea 元素使用 value 属性和 input 事件；")]),t._v(" "),a("li",[t._v("checkbox 和 radio 使用 checked 属性和 change 事件；")]),t._v(" "),a("li",[t._v("select 字段将 value 作为 prop 并将 change 作为事件。")])])]),t._v(" "),a("p",[a("strong",[t._v("以 input 表单元素为例：")])]),t._v(" "),a("div",{staticClass:"language-html extra-class"},[a("pre",{pre:!0,attrs:{class:"language-html"}},[a("code",[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("input")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("v-model")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")]),t._v("something"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("'")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n\n相当于\n"),a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token tag"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("input")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("v-bind:")]),t._v("value")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("something"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token attr-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("v-on:")]),t._v("input")]),a("span",{pre:!0,attrs:{class:"token attr-value"}},[a("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("something = $event.target.value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])])]),a("p",[t._v("如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示：")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 父组件：")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("ModelChild v"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("model"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"message"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("ModelChild"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 子组件：")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("div"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\nprops"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    value"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" String\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\nmethods"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("test1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n     "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("$emit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'input'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'小红'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),a("h2",{attrs:{id:"_20-vue-怎么实现对象和数组的监听？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-vue-怎么实现对象和数组的监听？"}},[t._v("#")]),t._v(" 20. Vue 怎么实现对象和数组的监听？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("如果被问到 Vue 怎么实现数据双向绑定，大家肯定都会回答 通过 Object.defineProperty() 对数据进行劫持，但是  Object.defineProperty() 只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是我们在使用 Vue 框架中都知道，Vue 能检测到对象和数组（部分方法的操作）的变化，那它是怎么实现的呢？我们查看相关代码如下：")])]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * Observe a list of Array items.\n */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observeArray")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("items"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Array"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("any"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" l "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" l"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// observe 功能为监测数据的变化")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n * 对属性进行递归遍历\n */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" childOb "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("shallow "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("observe")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("val"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// observe 功能为监测数据的变化")]),t._v("\n")])])]),a("p",[t._v("通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。")]),t._v(" "),a("h2",{attrs:{id:"_21-proxy-与-object-defineproperty-对比"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-proxy-与-object-defineproperty-对比"}},[t._v("#")]),t._v(" 21. Proxy 与 Object.defineProperty 对比")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Proxy 的优势如下:")]),t._v(" "),a("ol",[a("li",[t._v("Proxy 可以直接监听对象而非属性；")]),t._v(" "),a("li",[t._v("Proxy 可以直接监听数组的变化；")]),t._v(" "),a("li",[t._v("Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的；")]),t._v(" "),a("li",[t._v("Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改；")]),t._v(" "),a("li",[t._v("Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利；")])])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Object.defineProperty 的优势如下:")]),t._v(" "),a("p",[t._v("兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。")])]),t._v(" "),a("h2",{attrs:{id:"_21-vm-set-解决对象不能响应的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-vm-set-解决对象不能响应的问题"}},[t._v("#")]),t._v(" 21. vm.$set() 解决对象不能响应的问题?")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("受现代 JavaScript 的限制 ，Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的。但是 Vue 提供了 Vue.set (object, propertyName, value) / vm.$set (object, propertyName, value)  来实现为对象添加响应式属性，那框架本身是如何实现的呢？")])]),t._v(" "),a("p",[t._v("我们查看对应的 Vue 源码：vue/src/core/instance/index.js")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("set")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("target"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Array"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("any"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" Object"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" val"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// target 为数组  ")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Array"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isArray")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("isValidArrayIndex")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 修改数组的长度, 避免索引>数组长度导致splcie()执行有误")]),t._v("\n    target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" Math"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 利用数组的splice变异方法触发响应式  ")]),t._v("\n    target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("splice")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" val"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" val\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// key 已经存在，直接修改属性值  ")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" target "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("key "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("prototype"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" val\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" val\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" ob "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("target"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" any"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("__ob__\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// target 本身就不是响应式数据, 直接赋值")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("ob"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    target"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" val\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" val\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 对属性进行响应式处理")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("defineReactive")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("ob"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" val"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  ob"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dep"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("notify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" val\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("我们阅读以上源码可知，vm.$set 的实现原理是：")]),t._v(" "),a("ol",[a("li",[t._v("如果目标是数组，直接使用数组的 splice 方法触发相应式；")]),t._v(" "),a("li",[t._v("如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）")])])]),t._v(" "),a("h2",{attrs:{id:"_22-虚拟-dom-实现原理？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-虚拟-dom-实现原理？"}},[t._v("#")]),t._v(" 22. 虚拟 DOM 实现原理？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("虚拟 DOM 的实现原理主要包括以下 3 部分：")]),t._v(" "),a("ol",[a("li",[t._v("用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；")]),t._v(" "),a("li",[t._v("diff 算法 — 比较两棵虚拟 DOM 树的差异；")]),t._v(" "),a("li",[t._v("pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。")])])]),t._v(" "),a("h2",{attrs:{id:"_23-虚拟-dom-的优缺点？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-虚拟-dom-的优缺点？"}},[t._v("#")]),t._v(" 23. 虚拟 DOM 的优缺点？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("优点：")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("保证性能下限：")]),t._v(" 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；")]),t._v(" "),a("li",[a("strong",[t._v("无需手动操作 DOM：")]),t._v(" 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；")]),t._v(" "),a("li",[a("strong",[t._v("跨平台：")]),t._v(" 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。")])])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("缺点:")]),t._v(" "),a("p",[a("strong",[t._v("无法进行极致优化：")]),t._v(" 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。")])]),t._v(" "),a("h2",{attrs:{id:"_24-你有对-vue-项目进行哪些优化？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-你有对-vue-项目进行哪些优化？"}},[t._v("#")]),t._v(" 24. 你有对 Vue 项目进行哪些优化？")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("（1）代码层面的优化")]),t._v(" "),a("ol",[a("li",[t._v("v-if 和 v-show 区分使用场景")]),t._v(" "),a("li",[t._v("computed 和 watch  区分使用场景")]),t._v(" "),a("li",[t._v("v-for 遍历必须为 item 添加 key，且避免同时使用 v-if")]),t._v(" "),a("li",[t._v("长列表性能优化")]),t._v(" "),a("li",[t._v("事件的销毁")]),t._v(" "),a("li",[t._v("图片资源懒加载")]),t._v(" "),a("li",[t._v("路由懒加载")]),t._v(" "),a("li",[t._v("第三方插件的按需引入")]),t._v(" "),a("li",[t._v("优化无限列表性能")]),t._v(" "),a("li",[t._v("服务端渲染 SSR or 预渲染")])])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("（2）Webpack 层面的优化")]),t._v(" "),a("ol",[a("li",[t._v("Webpack 对图片进行压缩")]),t._v(" "),a("li",[t._v("减少 ES6 转为 ES5 的冗余代码")]),t._v(" "),a("li",[t._v("提取公共代码")]),t._v(" "),a("li",[t._v("模板预编译")]),t._v(" "),a("li",[t._v("提取组件的 CSS")]),t._v(" "),a("li",[t._v("优化 SourceMap")]),t._v(" "),a("li",[t._v("构建结果输出分析")]),t._v(" "),a("li",[t._v("Vue 项目的编译优化")])])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("（3）基础的 Web 技术的优化")]),t._v(" "),a("ol",[a("li",[t._v("开启 gzip 压缩")]),t._v(" "),a("li",[t._v("浏览器缓存")]),t._v(" "),a("li",[t._v("CDN 的使用")]),t._v(" "),a("li",[t._v("使用 Chrome Performance 查找性能瓶颈")])])]),t._v(" "),a("h2",{attrs:{id:"_25-vue3-0-特性你有什么了解的吗？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-vue3-0-特性你有什么了解的吗？"}},[t._v("#")]),t._v(" 25. vue3.0 特性你有什么了解的吗？")]),t._v(" "),a("p",[t._v("Vue 3.0 的目标是让 Vue 核心变得更小、更快、更强大，因此 Vue 3.0 增加以下这些新特性：")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("（1）监测机制的改变")]),t._v(" "),a("p",[t._v("3.0 将带来基于代理 Proxy 的 observer 实现，提供全语言覆盖的反应性跟踪。这消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：")]),t._v(" "),a("ol",[a("li",[t._v("只能监测属性，不能监测对象")]),t._v(" "),a("li",[t._v("检测属性的添加和删除；")]),t._v(" "),a("li",[t._v("检测数组索引和长度的变更；")]),t._v(" "),a("li",[t._v("支持 Map、Set、WeakMap 和 WeakSet。")])])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("新的 observer 还提供了以下特性：")]),t._v(" "),a("ol",[a("li",[t._v("用于创建 observable 的公开 API。这为中小规模场景提供了简单轻量级的跨组件状态管理解决方案。")]),t._v(" "),a("li",[t._v("默认采用惰性观察。在 2.x 中，不管反应式数据有多大，都会在启动时被观察到。如果你的数据集很大，这可能会在应用启动时带来明显的开销。在 3.x 中，只观察用于渲染应用程序最初可见部分的数据。")]),t._v(" "),a("li",[t._v("更精确的变更通知。在 2.x 中，通过 Vue.set 强制添加新属性将导致依赖于该对象的 watcher 收到变更通知。在 3.x 中，只有依赖于特定属性的 watcher 才会收到通知。")]),t._v(" "),a("li",[t._v("不可变的 observable：我们可以创建值的“不可变”版本（即使是嵌套属性），除非系统在内部暂时将其“解禁”。这个机制可用于冻结 prop 传递或 Vuex 状态树以外的变化。")]),t._v(" "),a("li",[t._v("更好的调试功能：我们可以使用新的 renderTracked 和 renderTriggered 钩子精确地跟踪组件在什么时候以及为什么重新渲染。")])])]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("（2）模板")]),t._v(" "),a("p",[t._v("模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。\n同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。")])]),t._v(" "),a("h2",{attrs:{id:"_26-vue事件绑定原理说一下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_26-vue事件绑定原理说一下"}},[t._v("#")]),t._v(" 26. Vue事件绑定原理说一下")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("原生事件绑定是通过addEventListener绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。")])])])}],!1,null,null,null);s.default=v.exports}}]);