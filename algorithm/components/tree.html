<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>树与二叉树 | 前端之路</title>
    <meta name="description" content="Personal Website">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.192449cd.css" as="style"><link rel="preload" href="/assets/js/app.e6490847.js" as="script"><link rel="preload" href="/assets/js/8.c039417d.js" as="script"><link rel="prefetch" href="/assets/js/10.2cbf406f.js"><link rel="prefetch" href="/assets/js/11.6230bdfc.js"><link rel="prefetch" href="/assets/js/12.fed9d7f7.js"><link rel="prefetch" href="/assets/js/13.bd71346f.js"><link rel="prefetch" href="/assets/js/14.91663730.js"><link rel="prefetch" href="/assets/js/15.afe89540.js"><link rel="prefetch" href="/assets/js/16.4e7f59eb.js"><link rel="prefetch" href="/assets/js/17.77286307.js"><link rel="prefetch" href="/assets/js/18.9da64000.js"><link rel="prefetch" href="/assets/js/19.3f677a26.js"><link rel="prefetch" href="/assets/js/2.9c48c232.js"><link rel="prefetch" href="/assets/js/20.7523e153.js"><link rel="prefetch" href="/assets/js/21.ad3c0855.js"><link rel="prefetch" href="/assets/js/22.bb901383.js"><link rel="prefetch" href="/assets/js/23.d9912c9e.js"><link rel="prefetch" href="/assets/js/24.53955016.js"><link rel="prefetch" href="/assets/js/25.86b73844.js"><link rel="prefetch" href="/assets/js/26.4aa4a47e.js"><link rel="prefetch" href="/assets/js/27.d66e7084.js"><link rel="prefetch" href="/assets/js/3.9df853b0.js"><link rel="prefetch" href="/assets/js/4.b1c1f607.js"><link rel="prefetch" href="/assets/js/5.8c110ab9.js"><link rel="prefetch" href="/assets/js/6.75e72418.js"><link rel="prefetch" href="/assets/js/7.e175f834.js"><link rel="prefetch" href="/assets/js/9.5618bdf4.js">
    <link rel="stylesheet" href="/assets/css/0.styles.192449cd.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端之路</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/basic/css/css.html" class="nav-link">前端基础</a></div><div class="nav-item"><a href="/algorithm/components/array.html" class="nav-link">算法</a></div><div class="nav-item"><a href="/typeScript/" class="nav-link">TypeScript</a></div><div class="nav-item"><a href="/webpack/webpack_basic.html" class="nav-link">Webpack</a></div><div class="nav-item"><a href="/interview/vue/vue.html" class="nav-link">高频面试题</a></div><div class="nav-item"><a href="http://dairuining.top/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  music
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/basic/css/css.html" class="nav-link">前端基础</a></div><div class="nav-item"><a href="/algorithm/components/array.html" class="nav-link">算法</a></div><div class="nav-item"><a href="/typeScript/" class="nav-link">TypeScript</a></div><div class="nav-item"><a href="/webpack/webpack_basic.html" class="nav-link">Webpack</a></div><div class="nav-item"><a href="/interview/vue/vue.html" class="nav-link">高频面试题</a></div><div class="nav-item"><a href="http://dairuining.top/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  music
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading"><span>开始</span> <!----></p> <ul class="sidebar-group-items"></ul></div></li><li><div class="sidebar-group"><p class="sidebar-heading open"><span>算法</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/algorithm/components/string.html" class="sidebar-link">字符串</a></li><li><a href="/algorithm/components/array.html" class="sidebar-link">数组</a></li><li><a href="/algorithm/components/linked.html" class="sidebar-link">链表</a></li><li><a href="/algorithm/components/queue.html" class="sidebar-link">队列</a></li><li><a href="/algorithm/components/sort.html" class="sidebar-link">排序</a></li><li><a href="/algorithm/components/tree.html" aria-current="page" class="active sidebar-link">二叉树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/components/tree.html#引言" class="sidebar-link">引言</a></li><li class="sidebar-sub-header"><a href="/algorithm/components/tree.html#树" class="sidebar-link">树</a></li><li class="sidebar-sub-header"><a href="/algorithm/components/tree.html#二叉树" class="sidebar-link">二叉树</a></li><li class="sidebar-sub-header"><a href="/algorithm/components/tree.html#平衡二叉树" class="sidebar-link">平衡二叉树</a></li><li class="sidebar-sub-header"><a href="/algorithm/components/tree.html#二叉树的遍历" class="sidebar-link">二叉树的遍历</a></li><li class="sidebar-sub-header"><a href="/algorithm/components/tree.html#二叉查找树（bst树）" class="sidebar-link">二叉查找树（BST树）</a></li><li class="sidebar-sub-header"><a href="/algorithm/components/tree.html#平衡二叉查找树（avl树）" class="sidebar-link">平衡二叉查找树（AVL树）</a></li><li class="sidebar-sub-header"><a href="/algorithm/components/tree.html#红黑树" class="sidebar-link">红黑树</a></li><li class="sidebar-sub-header"><a href="/algorithm/components/tree.html#trie-树" class="sidebar-link">Trie 树</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="树与二叉树"><a href="#树与二叉树" class="header-anchor">#</a> 树与二叉树</h1> <h2 id="引言"><a href="#引言" class="header-anchor">#</a> 引言</h2> <p>不同与我们之前介绍的线性结构，今天我们介绍一种非线性结构：树，本章重点介绍树与二叉树的基础必会内容，在开始这一章节前，请思考以下内容：</p> <ul><li>什么是树？</li> <li>什么是二叉树？</li> <li>什么是平衡二叉树？</li> <li>在代码中如何表示一棵二叉树？</li> <li>二叉树的前序、中序、后序遍历又是什么？如何实现？能否用递归及迭代两种方式实现喃？</li> <li>什么是 BST 树？</li> <li>什么是 AVL 树？</li> <li>什么是红黑树？</li> <li>什么是 Trie 树？</li> <li>什么是 B 、B+ 树？</li></ul> <h2 id="树"><a href="#树" class="header-anchor">#</a> 树</h2> <p>不同于我们上面介绍的线性结构，树是一种非线性结构。</p> <p>图：
<img src="http://resource.muyiy.cn/image/20210420231638.png" alt="树的结构">
它遵循：</p> <ul><li>仅有唯一一个根节点，没有节点则为空树</li> <li>除根节点外，每个节点都有并仅有唯一一个父节点</li> <li>节点间不能形成闭环
这就是树！</li></ul> <p>树有几个概念：</p> <ul><li>拥有相同父节点的节点，互称为兄弟节点</li> <li>节点的深度 ：从根节点到该节点所经历的边的个数</li> <li>节点的高度 ：节点到叶节点的最长路径</li> <li>树的高度：根节点的高度</li></ul> <h4 id="高度"><a href="#高度" class="header-anchor">#</a> 高度</h4> <p>树的高度计算公式：
<img src="http://resource.muyiy.cn/image/20200512000529.png" alt="树的高度计算公式">
下图每个节点值都代表来当前节点的高度：
<img src="http://resource.muyiy.cn/image/20200512000610.png" alt="节点的高度"></p> <h2 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h2> <p>二叉树，故名思义，最多仅有两个子节点的树（最多能分两个叉的树🤦‍♀️）：</p> <p>图：
<img src="http://resource.muyiy.cn/image/20210420231719.png" alt="二叉树结构"></p> <h2 id="平衡二叉树"><a href="#平衡二叉树" class="header-anchor">#</a> 平衡二叉树</h2> <p>二叉树中，每一个节点的左右子树的高度相差不能大于 1，称为平衡二叉树。
<img src="http://resource.muyiy.cn/image/20200512000105.png" alt="平衡二叉树结构">
另外还有满二叉树、完全二叉树等：</p> <ul><li><code>满二叉树</code>：除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树</li> <li><code>完全二叉树</code>：深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h 层所有的结点都连续集中在最左边
所以我们可以将每个节点定义为：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 保存当前节点 key 值</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val
  <span class="token comment">// 指向左子节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token comment">// 指向右子节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一棵二叉树可以由根节点通过左右指针连接起来形成一个树。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">BinaryTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token function-variable function">Node</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val
    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> root <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="数组存储法（适用于完全二叉树）"><a href="#数组存储法（适用于完全二叉树）" class="header-anchor">#</a> 数组存储法（适用于完全二叉树）</h4> <p>下图就是一棵完全二叉树，</p> <p>如果我们把根节点存放在位置 <code>i=1</code> 的位置，则它的左子节点位置为 <code>2i = 2</code> ，右子节点位置为 <code>2i+1 = 3</code> 。</p> <p>如果我们选取 <code>B</code> 节点 <code>i=2</code> ，则它父节点为 <code>i/2 = 1</code> ，左子节点 <code>2i=4</code> ，右子节点 <code>2i+1=5</code> 。</p> <p>以此类推，我们发现所有的节点都满足这三种关系：</p> <ul><li>位置为 <code>i</code> 的节点，它的父节点位置为 <code>i/2</code></li> <li>它的左子节点 <code>2i</code></li> <li>它的右子节点 <code>2i+1</code></li></ul> <p>因此，如果我们把完全二叉树存储在数组里（从下标为 1 开始存储），我们完全可以通过下标找到任意节点的父子节点。从而完整的构建出这个完全二叉树。这就是数组存储法。</p> <p>数组存储法相对于链式存储法不需要为每个节点创建它的左右指针，更为节省内存。
<img src="http://resource.muyiy.cn/image/20200323214643.png" alt="数组存储法"></p> <h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="header-anchor">#</a> 二叉树的遍历</h2> <p>二叉树的遍历可分为：</p> <ul><li>前序遍历</li> <li>中序遍历</li> <li>后序遍历</li></ul> <p>所谓前、中、后，不过是根的顺序，即也可以称为先根遍历、中根遍历、后根遍历</p> <h3 id="_1-前序遍历"><a href="#_1-前序遍历" class="header-anchor">#</a> 1. 前序遍历</h3> <p>对于二叉树中的任意一个节点，先打印该节点，然后是它的左子树，最后右子树
<img src="http://resource.muyiy.cn/image/20200511205130.png" alt="前序遍历"></p> <h3 id="_2-中序遍历"><a href="#_2-中序遍历" class="header-anchor">#</a> 2. 中序遍历</h3> <p>对于二叉树中的任意一个节点，先打印它的左子树，然后是该节点，最后右子树
<img src="http://resource.muyiy.cn/image/20200511205449.png" alt="中序遍历"></p> <h3 id="_3-后序遍历"><a href="#_3-后序遍历" class="header-anchor">#</a> 3. 后序遍历</h3> <p>对于二叉树中的任意一个节点，先打印它的左子树，然后是右子树，最后该节点
<img src="http://resource.muyiy.cn/image/20200511205837.png" alt="后序遍历"></p> <h3 id="_4-代码实现（前序遍历为例）"><a href="#_4-代码实现（前序遍历为例）" class="header-anchor">#</a> 4. 代码实现（前序遍历为例）</h3> <p>所以，遍历二叉树的过程也就是一个递归的过程，例如前序遍历，先遍历根节点，然后是根的左子树，最后右子树；遍历根节点的左子树的时候，又是先遍历左子树的根节点，然后左子树的左子树，左子树的右子树…….</p> <p>所以，它的核心代码就是：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 前序遍历核心代码</span>
<span class="token keyword">const</span> <span class="token function-variable function">preOrderTraverseNode</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先根节点</span>
    result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    <span class="token comment">// 然后遍历左子树</span>
    <span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token comment">// 再遍历右子树</span>
    <span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>完整代码如下：</p> <h4 id="递归实现"><a href="#递归实现" class="header-anchor">#</a> 递归实现</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 前序遍历</span>
<span class="token keyword">const</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">var</span> <span class="token function-variable function">preOrderTraverseNode</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 先根节点</span>
      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
      <span class="token comment">// 然后遍历左子树</span>
      <span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
      <span class="token comment">// 再遍历右子树</span>
      <span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
  <span class="token keyword">return</span> result
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们既然可以使用递归实现，那么是否也可以使用迭代实现喃？</p> <h4 id="迭代实现"><a href="#迭代实现" class="header-anchor">#</a> 迭代实现</h4> <p>利用栈来记录遍历的过程，实际上，递归就使用了调用栈，所以这里我们可以使用栈来模拟递归的过程</p> <ul><li>首先根入栈</li> <li>将根节点出栈，将根节点值放入结果数组中</li> <li>然后遍历左子树、右子树，因为栈是先入后出，所以，我们先右子树入栈，然后左子树入栈</li> <li>继续出栈（左子树被出栈）…….</li></ul> <p>依次循环出栈遍历入栈，直到栈为空，遍历完成</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 前序遍历</span>
<span class="token keyword">const</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 当根节点不为空的时候，将根节点入栈</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> curNode <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// 第一步的时候，先访问的是根节点</span>
    list<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
    <span class="token comment">// 我们先打印左子树，然后右子树</span>
    <span class="token comment">// 所以先加入栈的是右子树，然后左子树</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>curNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> list
<span class="token punctuation">}</span>
</code></pre></div><h4 id="复杂度分析："><a href="#复杂度分析：" class="header-anchor">#</a> 复杂度分析：</h4> <p>空间复杂度：O(n)</p> <p>时间复杂度：O(n)</p> <p>至此，我们已经实现了二叉树的前序遍历，尝试思考一下二叉树的中序遍历如何实现喃？</p> <h2 id="二叉查找树（bst树）"><a href="#二叉查找树（bst树）" class="header-anchor">#</a> 二叉查找树（BST树）</h2> <p>有的笔者也称它为二叉搜索树，都是一个意思。</p> <p>二叉树本身没有多大的意义，直到有位大佬提出一个 trick。</p> <p>如果我们规定一颗二叉树上的元素拥有顺序，所有比它小的元素在它的左子树，比它大的元素在它的右子树，那么我们不就可以很快地查找某个元素了吗？</p> <p>不得不说这是一个非常天才的想法，于是，二叉查找树诞生了。</p> <p>所以，二叉查找树与二叉树不同的是，它在二叉树的基础上，增加了对二叉树上节点存储位置的限制：二叉搜索树上的每个节点都需要满足：</p> <ul><li>左子节点值小于该节点值</li> <li>右子节点值大于等于该节点值
<img src="http://resource.muyiy.cn/image/20210420231841.png" alt="二叉查找树（BST树）">
在二叉树中，所有子节点值都是没有固定规律的，所以使用二叉树存储结构存储数据时，查找数据的时间复杂度为 O(n)，因为它要查找每一个节点。</li></ul> <p>而使用二叉查找树就不同了，例如上图，我们如果要查找 6 ，先从根节点 10 比较，6 比 10 小，则查找左子树，再与 8 比较，6 比 8 小，继续查找 8 的左子树，也就是 6，我们找到了元素，结束。</p> <h3 id="基本操作"><a href="#基本操作" class="header-anchor">#</a> 基本操作</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">BinarySearchTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> <span class="token function-variable function">Node</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key
    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> root <span class="token operator">=</span> <span class="token keyword">null</span>
  
  <span class="token comment">// 插入</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">insert</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 查找</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">search</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 删除</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">remove</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 最大值</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">max</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 最小值</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">min</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 中序遍历</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">inOrderTraverse</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 先序遍历</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">preOrderTraverse</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
  
  <span class="token comment">// 后序遍历</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">postOrderTraverse</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>插入</strong>：</p> <ul><li>首先创建一个新节点</li> <li>判断树是否为空，为空则设置插入的节点为根节点，插入成功，返回</li> <li>如果不为空，则比较该节点与根结点，比根小，插入左子树，否则插入右子树</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建新节点</span>
  <span class="token keyword">let</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
  <span class="token comment">// 判断是否为空树</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    root <span class="token operator">=</span> newNode
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">insertNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 将 insertNode 插入到 node 子树上</span>
<span class="token keyword">function</span> <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> newNode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>newNode<span class="token punctuation">.</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 插入 node 左子树</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node<span class="token punctuation">.</span>left <span class="token operator">=</span> newNode
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 插入 node 右子树</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node<span class="token punctuation">.</span>right <span class="token operator">=</span> newNode
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>最值：</strong></p> <p>最小值：树最左端的节点</p> <p>最大值：树最右端的节点</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 最小值</span>
<span class="token keyword">function</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> node <span class="token operator">=</span> root
  <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>left <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>left
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>key
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>

<span class="token comment">// 最大值</span>
<span class="token keyword">function</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> node <span class="token operator">=</span> root
  <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>right
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">.</span>key
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>查找：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">searchNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
    <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>删除：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  root <span class="token operator">=</span> <span class="token function">removeNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> 
    <span class="token keyword">return</span> <span class="token keyword">null</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// key = node.key 删除</span>
    <span class="token comment">//叶子节点</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token keyword">return</span> node
    <span class="token punctuation">}</span>
    <span class="token comment">// 只有一个子节点</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>right
      <span class="token keyword">return</span> node
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>left
      <span class="token keyword">return</span> node
    <span class="token punctuation">}</span>
    <span class="token comment">// 有两个子节点</span>
    <span class="token comment">// 获取右子树的最小值替换当前节点</span>
    <span class="token keyword">let</span> minRight <span class="token operator">=</span> <span class="token function">findMinNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
    node<span class="token punctuation">.</span>key <span class="token operator">=</span> minRight<span class="token punctuation">.</span>key
    node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minRight<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
    <span class="token keyword">return</span> node
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取 node 树最小节点</span>
<span class="token keyword">function</span> <span class="token function">findMinNode</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>node <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      node <span class="token operator">=</span> node<span class="token punctuation">.</span>right
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="遍历"><a href="#遍历" class="header-anchor">#</a> 遍历</h3> <h4 id="中序遍历："><a href="#中序遍历：" class="header-anchor">#</a> 中序遍历：</h4> <p>顾名思义，中序遍历就是把根放在中间的遍历，即按先左节点、然后根节点、最后右节点（左根右）的遍历方式。</p> <p>由于BST树任意节点都大于左子节点值小于等于右子节点值的特性，所以 中序遍历其实是对🌲进行排序操作 ，并且是按从小到大的顺序排序。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">inOrderTraverse</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先遍历左子树</span>
    <span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
    <span class="token comment">// 然后根节点</span>
    <span class="token function">callback</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
    <span class="token comment">// 再遍历右子树</span>
    <span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// callback 每次将遍历到的结果打印到控制台</span>
<span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="先序遍历："><a href="#先序遍历：" class="header-anchor">#</a> 先序遍历：</h4> <p>已经实现的中序遍历，先序遍历就很简单了，它是按根左右的顺序遍历</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先根节点</span>
    <span class="token function">callback</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
    <span class="token comment">// 然后遍历左子树</span>
    <span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
    <span class="token comment">// 再遍历右子树</span>
    <span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// callback 每次将遍历到的结果打印到控制台</span>
<span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="后序遍历："><a href="#后序遍历：" class="header-anchor">#</a> 后序遍历：</h4> <p>后序遍历按照左右根的顺序遍历，实现也很简单。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">postOrderTraverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先遍历左子树</span>
    <span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
    <span class="token comment">// 然后遍历右子树</span>
    <span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
    <span class="token comment">// 最后根节点</span>
    <span class="token function">callback</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>key<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// callback 每次将遍历到的结果打印到控制台</span>
<span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="bst树的局限"><a href="#bst树的局限" class="header-anchor">#</a> BST树的局限</h3> <p>在理想情况下，二叉树每多一层，可以存储的元素都增加一倍。也就是说 n 个元素的二叉搜索树，对应的树高为 O(logn)。所以我们查找元素、插入元素的时间也为 O(logn)。</p> <p>当然这是理想情况下，但在实际应用中，并不是那么理想，例如一直递增或递减的给一个二叉查找树插入数据，那么所有插入的元素就会一直出现在一个树的左节点上，数型结构就会退化为链表结构，时间复杂度就会趋于 O(n)，这是不好的。</p> <p>而我们上面的平衡树就可以很好的解决这个问题，所以平衡二叉查找树（<strong>AVL树，下一章节探讨</strong>）由此诞生。</p> <h2 id="平衡二叉查找树（avl树）"><a href="#平衡二叉查找树（avl树）" class="header-anchor">#</a> 平衡二叉查找树（AVL树）</h2> <p>故名思义，既满足左右子树高度不大于 1， 又满足任意节点值大于它的左子节点值，小于等于它的右子节点值。
<img src="http://resource.muyiy.cn/image/20210420231948.png" alt="平衡二叉查找树（AVL树）">
AVL 这个名字的由来，是它的两个发明者G. M. Adelson-Velsky 和 Evgenii Landis 的缩写，AVL最初是他们两人在1962 年的论文「An algorithm for the organization of information」中提出来一种数据结构</p> <h2 id="红黑树"><a href="#红黑树" class="header-anchor">#</a> 红黑树</h2> <p>红黑树也是一种特殊的「二叉查找树」。</p> <p>到目前为止我们学习的 AVL 树和即将学习的红黑树都是二叉查找树的变体，可见二叉查找树真的是非常重要基础二叉树，如果忘了它的定义可以先回头看看。</p> <p>红黑树是一种比较难的数据结构，面试中很少有面试官让你手写一个红黑树，最多的话是考察你是否理解红黑树，以及为什么有了 AVL 树还需要红黑树，本部分就主要介绍这块。</p> <h3 id="什么是红黑树"><a href="#什么是红黑树" class="header-anchor">#</a> 什么是红黑树</h3> <p>红黑树是一种自平衡（并不是绝对平衡）的二叉查找树，它除了满足二分查找树的特点外，还满足以下条件：</p> <ul><li>节点是红色或黑色</li> <li>根节点必须是黑色节点</li> <li>所有的叶子节点都必须是值为 NULL 的黑节点</li> <li>如果一个节点是红色的，则它两个子节点都是黑色的</li> <li>从任一节点到达它的每个叶子节点的所有的路径，都有相同数目的黑色节点</li></ul> <p><img src="http://resource.muyiy.cn/image/20210420232032.png" alt="什么是红黑树">
很多人不理解为神马要有那么多条条框框，这里引用王争老师的说法：</p> <blockquote><p>我们都玩过魔方吧，其实魔方的复原是有固定算法的，遇到哪几面是什么样的，你就对应转几下，只要跟着这个复原步骤，最终肯定能把魔方复原。红黑树也是的，它也有固定的条条框框，在插入、删除时也有固定的调整方案。</p></blockquote> <p>这些条条框框保证红黑树的自平衡，保证红黑树从根节点到达每一个叶子节点的最长路径不会超过最短路径的 2 倍。</p> <p>而节点的路径长度决定着对节点的查询效率，这样我们确保了，最坏情况下的查找、插入、删除操作的时间复杂度不超过 O(logn) ，并且有较高的插入和删除效率。</p> <h3 id="红黑树-vs-平衡二叉树（avl树）"><a href="#红黑树-vs-平衡二叉树（avl树）" class="header-anchor">#</a> 红黑树 VS 平衡二叉树（AVL树）</h3> <ul><li>插入和删除操作，一般认为红黑树的删除和插入会比 AVL 树更快。因为，红黑树不像 AVL 树那样严格的要求平衡因子小于等于1，这就减少了为了达到平衡而进行的旋转操作次数，可以说是牺牲严格平衡性来换取更快的插入和删除时间。</li> <li>红黑树不要求有不严格的平衡性控制，但是红黑树的特点，使得任何不平衡都会在三次旋转之内解决。而 AVL 树如果不平衡，并不会控制旋转操作次数，旋转直到平衡为止。</li> <li>查找操作，AVL树的效率更高。因为 AVL 树设计比红黑树更加平衡，不会出现平衡因子超过 1 的情况，减少了树的平均搜索长度。</li></ul> <h2 id="trie-树"><a href="#trie-树" class="header-anchor">#</a> Trie 树</h2> <h3 id="什么是-trie-树"><a href="#什么是-trie-树" class="header-anchor">#</a> 什么是 Trie 树</h3> <p>Trie 树，也称为字典树或前缀树，顾名思义，它是用来处理字符串匹配问题的数据结构，以及用来解决集合中查找固定前缀字符串的数据结构。</p> <h3 id="trie树的应用：字符串匹配"><a href="#trie树的应用：字符串匹配" class="header-anchor">#</a> Trie树的应用：字符串匹配</h3> <p>在搜索引擎中输入关键字，搜索引擎都会弹出下拉框，显示各种关键字提示，例如必应：
<img src="http://resource.muyiy.cn/image/20200324211835.png" alt="Trie树的应用：字符串匹配"></p> <p>必应是如何处理这一过程的喃？</p> <p>或者，假设我们有<code>n</code>个单词的数据集，任意输入一串字符，如何在数据集中快速匹配出具有输入字符前缀的单词？</p> <p>这样类似的问题还有很多，在日常开发中，遇到类似的问题，我们应该如何去处理？选择怎样的数据结构与算法？尤其是遇到大规模数据时，如何更高效的处理？</p> <p>最简单的方法就是暴力，将数据集中的每个字符串，逐个字符的匹配输入字符，所有字符都匹配上则前缀匹配成功。这种方式也是我们开发当中最常用，最简单的方式，时间复杂度为 <code>O(m*n)</code> ，其中 <code>m</code> 为输入字符串长度， <code>n</code> 为数据集规模。</p> <p>这个时间复杂度是很高的，当 <code>n</code> 很大时，暴力法性能就会很差，此时必须重新寻找合适的算法。</p> <p>我们知道在树上查找、插入都比较方便，一般时间复杂度只与树的高度相关，我们可以通过树结构来处理，也就是我们要说的 Trie 树。其实，引擎搜索关键字提示底层也是通过 Trie 树实现的。</p> <p>举个例子：假设数据集有：<code>are</code> 、 <code>add</code> 、 <code>adopt</code> 、<code>set</code> 、<code>so</code> ，它构键过程：
<img src="http://resource.muyiy.cn/image/20200324214338.png" alt="构键过程"></p> <p>当所以的字符串插入完成，Trie树就构建完成了。</p> <p><code>Trie树</code>的本质是利用字符串的公共前缀，将重复的前缀合并在一起，其中根节点不包含任何信息，每个节点表示一个字符串中的字符，从根节点到叶节点的路径，表示一个字符串。</p> <p>在字符串匹配的时候，我们只要按照树的结构从上到下匹配即可。</p></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/algorithm/components/sort.html" class="prev">
          排序
        </a></span> <!----></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.e6490847.js" defer></script><script src="/assets/js/8.c039417d.js" defer></script>
  </body>
</html>
